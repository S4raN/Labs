New Chat


Очистить историю
Настройки

Светлый режим
Русский
Open sidebar
New Chat

Напиши код на C++:
Задания:

Самостоятельно определите иерархию классов, приведенных в задании (в соответствии с вариантом — выделить базовый и производные от него классы). В базовом классе должны быть объявлены поля и методы, общие для данного класса и всех классов-наследников: show(), get(), set() и другие, специфические для данного класса. Здесь виртуальный метод show() выводит информацию об объекте и имеет свою реализацию в каждом производном классе; get() — ввода полей класса с клавиатуры,... В производном классе добавляются поля и методы, специфические для данного класса, а также реализация виртуальных методов, объявленных в базовом классе. Там, где это необходимо, использовать виртуальные и перегруженные методы. Часть методов переопределить.
Необходимые поля и методы каждый студент определяет самостоятельно, исходя из специфики задачи. В производных классах добавляется еще минимум 2 поля. Минимальное количество методов базового класса — 4 (в том числе вывод на экран состояния экземпляра класса, ввода полей класса с клавиатуры), в производных классах добавляется еще минимум 2 метода.
Определить в классах все необходимые конструкторы, включая конструкторы по- умолчанию, конструктор копирования и деструкторы (возможно, виртуальные деструкторы).
В программе, демонстрирующей работу с классами (всех методов), необходимо создать, массив указателей на объекты базового класса и заполнить указателями на объекты производных классов. Далее использовать эти указатели для вызова необходимых методов. Вызвать метод show( ) базового класса и просмотреть массив объектов.
Определение каждого класса (.h) ‚его реализацию (.срр) , демонстрационную программу (*.срр) поместить в отдельные файлы. ВАРИАНТ: (Использовать объекты для моделирования реальных ситуаций) 4. Классы — кадры (имя, ...), рабочий (специальность, цех, подразделение, ...), администрация (должность, ..)



// Класс "Кадры"
class Kadry {
protected:
string name;
public:
Kadry() {}
Kadry(string n) : name(n) {}

c
Copy code
virtual void show() {
    cout << "Имя: " << name << endl;
}
virtual void get() {
    cout << "Введите имя: ";
    cin >> name;
}
};

// Класс "Рабочий"
class Rabochiy : public Kadry {
private:
string specialty;
string workshop;
string subdivision;
public:
Rabochiy() {}
Rabochiy(string n, string s, string w, string sub)
: Kadry(n), specialty(s), workshop(w), subdivision(sub) {}

c
Copy code
void show() {
    cout << "Имя: " << name << endl;
    cout << "Специальность: " << specialty << endl;
    cout << "Цех: " << workshop << endl;
    cout << "Подразделение: " << subdivision << endl;
}
void get() {
    cout << "Введите имя: ";
    cin >> name;
    cout << "Введите специальность: ";
    cin >> specialty;
    cout << "Введите цех: ";
    cin >> workshop;
    cout << "Введите подразделение: ";
    cin >> subdivision;
}

void work() {
    cout << name << " работает в цеху " << workshop << endl;
}
void setSubdivision(string sub) {
    subdivision = sub;
}
};

// Класс "Администрация"
class Administration : public Kadry {
private:
string position;
public:
Administration() {}
Administration(string n, string pos) : Kadry(n), position(pos) {}

c
Copy code
void show() {
    cout << "Имя: " << name << endl;
    cout << "Должность: " << position << endl;
}
void get() {
    cout << "Введите имя: ";
    cin >> name;
    cout << "Введите должность: ";
    cin >> position;
}

void manage() {
    cout << name << " управляет подразделением" << endl;
}
void setPosition(string pos) {
    position = pos;
}
};

int main() {
Kadry* kadr[3]; // массив указателей на объекты базового класса
kadr[0] = new Rabochiy("Иванов", "слесарь", "1", "механическое производство");
kadr[1] = new Administration("Петров", "главный инженер");
kadr[2] = new Rabochiy("Сидоров", "электрик", "2", "электротехническое производство");

scss
Copy code
for(int i = 0; i < 3; i++) {
    kadr[i]->show();
    if(Rabochiy* r = dynamic_cast<Rabochiy*>(kadr[i]))
        r->work();
    else if(Administration* a = dynamic_cast<Administration*>(kadr[i]))
        a->manage();
    cout << endl;
}

for(int i = 0; i < 3; i++)
    delete kadr[i];

return 0;
}





Введите ваш текст ...

Отправить

Сохранить
9 / 10 сообщений осталось
Скачать чат
