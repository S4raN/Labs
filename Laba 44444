#include <iostream>
#include <vector>
#include <ctime>
using namespace std;

// Функция для вывода матрицы
void printMatrix(vector<vector<double>>& matrix) {
    for (int i = 0; i < matrix.size(); ++i) {
        for (int j = 0; j < matrix[i].size(); ++j) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
}

// Функция для создания единичной матрицы той же размерности
vector<vector<double>> identityMatrix(int n) {
    vector<vector<double>> identity(n, vector<double>(n, 0));
    for (int i = 0; i < n; ++i) {
        identity[i][i] = 1;
    }
    return identity;
}

// Функция для нахождения обратной матрицы методом Гаусса
vector<vector<double>> inverseMatrix(vector<vector<double>>& matrix) {
    int n = matrix.size();
    vector<vector<double>> identity = identityMatrix(n);

    for (int i = 0; i < n; ++i) {
        // Приводим главный элемент к 1
        double pivot = matrix[i][i];
        for (int j = 0; j < n; ++j) {
            matrix[i][j] /= pivot;
            identity[i][j] /= pivot;
        }

        // Обнуляем остальные элементы в столбце
        for (int k = 0; k < n; ++k) {
            if (k != i) {
                double factor = matrix[k][i];
                for (int j = 0; j < n; ++j) {
                    matrix[k][j] -= factor * matrix[i][j];
                    identity[k][j] -= factor * identity[i][j];
                }
            }
        }
    }

    return identity;
}

int main() {
    vector<vector<double>> matrix = { {1, 0, 0},
                                      {0, 1, 0},
                                      {0, 0, 1}};

    cout << "Original Matrix:" << endl;
    printMatrix(matrix);

    vector<vector<double>> inverse = inverseMatrix(matrix);

    cout << "\nInverse Matrix:" << endl;
    printMatrix(inverse);

    return 0;
}
//метод Гаусса поиска обратной матрицы
